# Relay Envelope Specification

**Status:** Draft
**Phase:** 5A (spec-only)
**Baseline:** `daemon-v0.1.5-smoke-chunked-send`
**Temporary home:** bolt-daemon (migrates to bolt-protocol or bytebolt-relay when active)

---

## 1. Purpose

The Relay Envelope is the framing format for forwarding opaque Bolt Protocol
encrypted envelopes through a ByteBolt relay. It provides the minimum routing
information needed for the relay to deliver a message from one peer to the
paired peer within a session.

The relay envelope does NOT provide encryption, authentication, integrity
verification, ordering, or any transformation of the inner payload. Those
properties are provided by the Bolt Protocol encrypted envelope (PROTOCOL.md
section 6.1) and the underlying transport, respectively.

Nesting:

```
Relay Envelope
  -> Bolt Encrypted Envelope (opaque to relay)
       -> Plaintext Bolt message (opaque to relay and to envelope layer)
```

The relay sees only the relay envelope header fields and the payload length.
The payload bytes are opaque.

---

## 2. Constraints

The relay envelope:

1. MUST wrap exactly one Bolt encrypted envelope per relay frame.
2. MUST NOT split a Bolt encrypted envelope across multiple relay frames.
3. MUST NOT coalesce multiple Bolt encrypted envelopes into a single relay frame.
4. MUST NOT alter, inspect, parse, or depend on the payload bytes.
5. MUST NOT embed filenames, file sizes, content types, or user identifiers.
6. MUST NOT add cryptographic layers (encryption, signing, MAC) beyond what
   the Bolt Protocol already provides.
7. MUST NOT introduce compression.
8. MUST NOT depend on any specific transport (SCTP, WebSocket, WebRTC, TCP,
   QUIC, or any other).
9. MUST remain deterministic: identical inputs produce identical envelope bytes.

One-envelope-per-frame invariant: the relay forwards each encrypted envelope
as a discrete unit. This preserves the Bolt Protocol guarantee that each
`FILE_CHUNK` is individually encrypted in its own envelope (PROTOCOL.md
section 8).

---

## 3. Envelope Structure

### 3.1 Wire Format

All multi-byte integers are big-endian (network byte order).

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    version    |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                         session_id                            |
+                                                               +
|                          (16 bytes)                           |
+                                               +-+-+-+-+-+-+-+-+
|                                               |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
|                      payload_length                           |
+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                          payload                              |
+                       (variable length)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 3.2 Field Definitions

| Offset | Field | Type | Size | Description |
|--------|-------|------|------|-------------|
| 0 | `version` | uint8 | 1 byte | Relay envelope version. MUST be `1`. |
| 1 | `session_id` | bytes | 16 bytes | Relay-assigned session identifier. |
| 17 | `payload_length` | uint32 | 4 bytes | Length of `payload` in bytes. Big-endian. |
| 21 | `payload` | bytes | variable | Opaque Bolt encrypted envelope bytes. |

**Total header size:** 21 bytes (fixed).
**Total frame size:** 21 + `payload_length` bytes.

### 3.3 Field Semantics

**`version`** (uint8)

Protocol version for the relay envelope format. This specification defines
version 1. Implementations MUST reject envelopes with `version != 1` and
MUST NOT attempt to parse them. Future versions MAY change the header layout.

**`session_id`** (bytes16)

Opaque 16-byte identifier assigned by the relay during session setup. Both
peers in a session use the same `session_id`. The relay uses this field to
look up the paired peer and forward the payload.

Properties:
- Generated by the relay, not by peers.
- Cryptographically random (CSPRNG), not derived from peer codes, user
  identifiers, IP addresses, or any user-facing data.
- Ephemeral: valid only for the duration of the relay session.
- Peers treat `session_id` as opaque bytes. Peers MUST NOT interpret,
  parse, or derive meaning from the value.
- Collision probability: negligible at 128 bits (birthday bound ~2^64 sessions).

**`payload_length`** (uint32, big-endian)

Length of the `payload` field in bytes. Maximum value: 2^32 - 1 (4,294,967,295).
In practice, individual Bolt encrypted envelopes are small:

- Protocol-level chunk size: 16,384 bytes plaintext (PROTOCOL.md `DEFAULT_CHUNK_SIZE`).
- Each `FILE_CHUNK` plaintext is wrapped in a Bolt encrypted envelope adding
  56 bytes of overhead (32-byte `sender_ephemeral_key` + 24-byte `nonce`)
  plus NaCl box expansion (16-byte Poly1305 MAC).
- Typical encrypted envelope size: ~16,456 bytes per file chunk.
- Control messages (HELLO, FILE_OFFER, etc.) are significantly smaller.

Implementations SHOULD reject `payload_length` values exceeding a configured
maximum (relay policy, not protocol-mandated). A reasonable default maximum
is 65,536 bytes, which accommodates any chunk size up to ~65 KiB plaintext.

**`payload`** (bytes, variable)

The opaque Bolt encrypted envelope. The relay MUST forward these bytes
verbatim without modification, inspection, or interpretation.

The inner structure (defined in PROTOCOL.md section 6.1, reproduced here for
reference only — the relay MUST NOT parse this) is:

| Inner field | Type | Description |
|-------------|------|-------------|
| `sender_ephemeral_key` | bytes32 | Sender's ephemeral X25519 public key |
| `nonce` | bytes24 | Cryptographically random nonce |
| `ciphertext` | bytes | NaCl box output (includes 16-byte Poly1305 MAC) |

The relay does not know and MUST NOT attempt to determine which Bolt message
type is inside the ciphertext.

---

## 4. Session Identification Model

### 4.1 Session Lifecycle

A relay session is a pairing between exactly two peers for the duration of
a file transfer (or series of transfers). The lifecycle is:

1. **Setup:** Both peers connect to the relay and are paired. The relay
   generates a `session_id` and communicates it to both peers. Session
   setup is out of scope for this envelope specification (it is a relay
   signaling concern, analogous to rendezvous).

2. **Data phase:** Peers exchange relay envelopes. The relay forwards each
   envelope to the paired peer using `session_id` for routing.

3. **Teardown:** Either peer disconnects or the relay terminates the session.
   The `session_id` is invalidated. Future envelopes with this `session_id`
   MUST be rejected.

### 4.2 Session Properties

- A `session_id` maps to exactly two peers (1:1 pairing).
- A `session_id` is never reused after teardown.
- The relay maintains a session table mapping `session_id` to two peer
  connections. This is the only relay state.
- No transfer-level state: the relay does not track `transfer_id`,
  `chunk_index`, file sizes, or transfer progress. Those are Bolt Protocol
  concerns, opaque to the relay.

### 4.3 Session Identity Isolation

The `session_id` is:
- Not derived from peer codes (PROTOCOL.md `PEER_CODE_LENGTH` = 6 characters).
- Not derived from identity keys (PROTOCOL.md `PUBLIC_KEY_LENGTH` = 32 bytes).
- Not derived from IP addresses or transport endpoints.
- Not derivable by an observer who does not control the relay.

An observer who captures relay traffic sees `session_id` values but cannot
link them to Bolt Protocol peer codes, identity keys, or user identifiers
without compromising the relay itself.

---

## 5. Routing Semantics

### 5.1 Forwarding Rule

The relay applies a single deterministic routing rule:

```
On receiving a relay envelope from Peer A in session S:
  1. Validate version == 1. If not, drop and signal error.
  2. Look up session S in the session table.
  3. If session S does not exist, drop and signal error.
  4. Identify the paired peer (Peer B) in session S.
  5. Forward the relay envelope verbatim to Peer B.
```

The relay does not modify any field. The relay does not add headers, trailers,
timestamps, or sequence numbers. The relay does not rewrite the `session_id`.

### 5.2 No Content-Based Routing

The relay MUST NOT make routing decisions based on payload content. All
envelopes within a session are forwarded to the same paired peer regardless
of payload size, content, or timing.

### 5.3 No Store-and-Forward

The relay operates in cut-through mode. If the destination peer is not
currently connected, the relay MUST NOT buffer or store the envelope for
later delivery. The envelope is dropped and the sender is notified of the
delivery failure (via transport-level error or relay signaling).

---

## 6. Failure Behavior

### 6.1 Envelope Validation Failures

| Condition | Relay action |
|-----------|-------------|
| `version != 1` | Drop envelope. Signal error to sender. |
| `session_id` not found | Drop envelope. Signal error to sender. |
| `payload_length` exceeds maximum | Drop envelope. Signal error to sender. |
| `payload` shorter than `payload_length` | Drop envelope (truncated frame). Signal error to sender. |
| `payload_length == 0` | Drop envelope. Signal error to sender. |

The relay MUST NOT forward invalid envelopes. Error signaling mechanism is
transport-dependent and out of scope for this specification.

### 6.2 Peer Disconnection

When a peer disconnects (graceful or abrupt):

1. The relay terminates the session.
2. The relay signals session termination to the remaining peer (mechanism
   transport-dependent).
3. The relay invalidates the `session_id`. Future envelopes with this
   `session_id` are rejected.

### 6.3 Relay Restart

The relay is ephemeral. On restart, all session state is lost. Both peers
must re-establish their session. The relay does not persist session state
to disk.

---

## 7. Replay Handling Policy

### 7.1 Relay Layer: No Replay Detection

The relay does NOT perform replay detection. The relay is a stateless
forwarder (no per-envelope tracking beyond session routing). Adding replay
detection at the relay layer would require the relay to maintain per-message
state, inspect payload content, or both — violating opacity and minimality.

### 7.2 Bolt Protocol Layer: Replay Detection

Replay protection is the responsibility of the Bolt Protocol layer:

- **Per-message integrity:** Each Bolt encrypted envelope includes a
  Poly1305 MAC (NaCl box). Modification is detected by the receiver.
- **Nonce uniqueness:** Each envelope uses a fresh 24-byte random nonce
  (PROTOCOL.md section 6.1). Replaying an envelope with the same nonce
  is detectable if the receiver tracks seen nonces.
- **Transfer-level dedup:** Receivers reject duplicate `(transfer_id,
  chunk_index)` pairs (PROTOCOL.md section 8). A replayed `FILE_CHUNK`
  with an already-received index is discarded.
- **Ephemeral keys:** Keypairs are generated per session and discarded
  after termination. Replaying envelopes from a previous session fails
  decryption because the receiver no longer holds the corresponding
  ephemeral secret key.

### 7.3 Justification

The relay cannot perform meaningful replay detection because:
1. It cannot read the ciphertext (no keys).
2. It does not know message types, transfer IDs, or chunk indices.
3. Adding sequence numbers to the relay envelope would constitute metadata
   enrichment and would not prevent an attacker who controls the relay
   from injecting fabricated sequence numbers.

The Bolt Protocol's layered replay defenses (MAC, nonce, dedup, ephemeral
keys) are sufficient without relay cooperation.

---

## 8. Metadata Minimization Analysis

### 8.1 Fields Present

| Field | Justification | Minimization |
|-------|--------------|--------------|
| `version` | Required for forward compatibility. | 1 byte. Minimum viable. |
| `session_id` | Required for routing. | 16 bytes. Relay-generated, opaque, ephemeral. Not linked to user identity. |
| `payload_length` | Required for framing. | 4 bytes. Reveals encrypted envelope size only. |
| `payload` | The data being forwarded. | Opaque. Relay cannot read. |

### 8.2 Fields Absent (By Design)

| Absent field | Reason for exclusion |
|-------------|---------------------|
| Timestamp | Metadata enrichment. Timing analysis is a transport-layer observable regardless; adding explicit timestamps only aids attackers. |
| Sequence number | Metadata enrichment. Ordering is a transport-layer concern. Bolt Protocol provides its own chunk ordering. |
| Sender identifier | Unnecessary. Relay knows the sender from the connection context. Adding it to the envelope leaks identity information if the envelope is captured. |
| Message type | Opaque payload. Relay must not know or act on content type. |
| Content length hint | Redundant with `payload_length`. Any additional size metadata aids traffic analysis. |
| Direction flag | Unnecessary. Relay determines direction from connection context. |
| TTL / hop count | Not applicable. Relay is a single hop. |
| Priority | Metadata enrichment. All envelopes are equal. |
| Compression flag | Compression is forbidden (constraint 7 in section 2). |

### 8.3 Traffic Analysis Considerations

An observer of relay traffic can observe:
- Envelope timing (inter-arrival intervals)
- Envelope sizes (`payload_length` values)
- Session existence (repeated `session_id`)
- Session duration

An observer CANNOT determine from the relay envelope:
- File names, file sizes, or content types
- Number of files transferred
- Transfer progress (chunk indices are encrypted)
- Peer identity (peer codes, identity keys are encrypted or absent)
- Which peer is sender vs. receiver for a given envelope

The `payload_length` field leaks encrypted envelope size. Because Bolt
Protocol uses a fixed default chunk size (16,384 bytes), most data-phase
envelopes will have similar `payload_length` values (~16,456 bytes after
encryption overhead), limiting the information gained from size analysis.
Control messages (HELLO, FILE_OFFER) are smaller but infrequent.

Padding to a fixed envelope size would further reduce traffic analysis
but is a transport-layer or profile-level concern, not a relay envelope
concern.

---

## 9. Transport Layer Independence

### 9.1 Statement

The relay envelope format is transport-agnostic. It defines a byte-level
framing that can be carried over any reliable, ordered, byte-stream or
message-oriented transport, including but not limited to:

- WebSocket (binary frames)
- TCP (length-prefixed)
- QUIC streams
- Unix domain sockets
- Any future transport

### 9.2 Transport Responsibilities

The relay envelope assumes the transport provides:

| Property | Required | Rationale |
|----------|----------|-----------|
| Reliable delivery | Yes | The relay does not retransmit. Lost envelopes cause transfer failure at the Bolt Protocol layer. |
| Ordered delivery | Yes | Bolt Protocol expects chunks in order (or re-orderable by `chunk_index`). The relay does not reorder. |
| Framing | Transport-dependent | Message-oriented transports (WebSocket) provide native framing. Stream transports (TCP) require the receiver to read the 21-byte header, extract `payload_length`, then read that many payload bytes. |

### 9.3 What the Relay Envelope Does NOT Assume

- No assumption about maximum message size (transport-specific).
- No assumption about SCTP, DTLS, or WebRTC (those are bolt-daemon's
  current peer-to-peer transport, not relevant to relay forwarding).
- No assumption about TLS (transport-layer encryption between peer and
  relay is a deployment concern, not an envelope concern).
- No assumption about connection multiplexing.
- The 64 KiB SCTP chunking in bolt-daemon's smoke mode sender is a
  transport-layer workaround for libdatachannel's message size limit.
  It is NOT a relay envelope concern and MUST NOT be hardcoded into
  this specification.

---

## 10. No-Drift Confirmation

### 10.1 Bolt Protocol Encrypted Envelope: Unchanged

This specification does NOT modify the Bolt Protocol encrypted envelope
defined in PROTOCOL.md section 6.1:

| Field | Type | Status |
|-------|------|--------|
| `sender_ephemeral_key` | bytes32 | **Unchanged** |
| `nonce` | bytes24 | **Unchanged** |
| `ciphertext` | bytes (NaCl box output) | **Unchanged** |

The encryption algorithm (NaCl box = X25519 + XSalsa20 + Poly1305),
key derivation, nonce generation, and MAC verification are all unchanged.

### 10.2 Bolt Protocol Messages: Unchanged

All message schemas defined in PROTOCOL.md section 7 (HELLO, FILE_OFFER,
FILE_ACCEPT, FILE_CHUNK, FILE_FINISH, PAUSE, RESUME, CANCEL, ERROR,
PING, PONG) are unchanged.

### 10.3 File Transfer Semantics: Unchanged

Chunking rules, `DEFAULT_CHUNK_SIZE` (16,384 bytes), backpressure, file
integrity verification, replay protection scoping, and resource limits
as defined in PROTOCOL.md section 8 are all unchanged.

### 10.4 Handshake Model: Unchanged

The Bolt Protocol handshake (HELLO exchange, TOFU verification, SAS
confirmation) is unchanged. The relay envelope carries handshake messages
as opaque encrypted envelopes, identical to data messages.

### 10.5 What This Specification Adds

This specification adds exactly one thing: a 21-byte relay envelope header
(`version` + `session_id` + `payload_length`) prepended to each Bolt
encrypted envelope when forwarded through a ByteBolt relay. This header
is stripped by the receiving peer before processing the inner Bolt encrypted
envelope. No inner structures are modified.

---

## Appendix A: Envelope Construction (Pseudocode)

### Sender (peer → relay)

```
fn wrap_for_relay(session_id: [u8; 16], bolt_envelope: &[u8]) -> Vec<u8> {
    let mut frame = Vec::with_capacity(21 + bolt_envelope.len());
    frame.push(1);                                    // version
    frame.extend_from_slice(&session_id);             // session_id
    frame.extend_from_slice(
        &(bolt_envelope.len() as u32).to_be_bytes()  // payload_length
    );
    frame.extend_from_slice(bolt_envelope);           // payload
    frame
}
```

### Receiver (relay → peer)

```
fn unwrap_from_relay(frame: &[u8]) -> Result<(u8, [u8; 16], &[u8]), Error> {
    if frame.len() < 21 {
        return Err(Error::TruncatedHeader);
    }
    let version = frame[0];
    if version != 1 {
        return Err(Error::UnsupportedVersion(version));
    }
    let mut session_id = [0u8; 16];
    session_id.copy_from_slice(&frame[1..17]);
    let payload_length = u32::from_be_bytes(
        frame[17..21].try_into().unwrap()
    ) as usize;
    if frame.len() < 21 + payload_length {
        return Err(Error::TruncatedPayload);
    }
    let payload = &frame[21..21 + payload_length];
    Ok((version, session_id, payload))
}
```

---

## Appendix B: Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `RELAY_ENVELOPE_VERSION` | `1` | Current relay envelope version |
| `RELAY_SESSION_ID_LENGTH` | `16` bytes | Session identifier length |
| `RELAY_HEADER_SIZE` | `21` bytes | Fixed header size (1 + 16 + 4) |
| `RELAY_MAX_PAYLOAD_DEFAULT` | `65536` bytes | Recommended maximum payload size |

---

## Appendix C: Relationship to Existing Components

| Component | Relationship to relay envelope |
|-----------|-------------------------------|
| Bolt encrypted envelope (PROTOCOL.md section 6.1) | Inner payload. Opaque to relay. Unchanged. |
| Rendezvous signaling (bolt-rendezvous) | Separate concern. Rendezvous pairs peers; relay forwards data. Wire formats are independent. Relay envelope MUST NOT modify rendezvous wire format. |
| bolt-daemon smoke mode | Test infrastructure. SCTP chunking and SHA-256 verification are transport/test concerns, not relay concerns. |
| ICE candidate filtering (ice_filter.rs) | Peer-to-peer concern. Not applicable to relay transport. |
| `DEFAULT_CHUNK_SIZE` (16,384 bytes) | Bolt Protocol constant. Determines typical `payload_length` values. Not a relay constant. |
