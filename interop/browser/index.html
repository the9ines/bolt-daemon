<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>bolt-daemon browser interop</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: monospace; padding: 1em; max-width: 60em; margin: auto; line-height: 1.5; }
  h1 { font-size: 1.2em; margin-bottom: 0.5em; }
  h2 { font-size: 1em; margin-top: 1em; margin-bottom: 0.3em; }
  textarea { width: 100%; height: 8em; font-family: monospace; font-size: 0.85em; }
  button { margin: 0.3em 0; padding: 0.3em 1em; cursor: pointer; }
  .log { background: #111; color: #0f0; padding: 0.5em; height: 12em; overflow-y: auto; font-size: 0.8em; white-space: pre-wrap; }
  .status { font-weight: bold; }
  .ok { color: green; }
  .err { color: red; }
  section { margin-bottom: 1em; border: 1px solid #ccc; padding: 0.5em; }
</style>
</head>
<body>
<h1>bolt-daemon &harr; browser interop</h1>
<p>Manual file-based signaling. No rendezvous server.</p>

<section>
  <h2>1. Mode</h2>
  <label><input type="radio" name="mode" value="offerer"> Browser is Offerer</label>&nbsp;
  <label><input type="radio" name="mode" value="answerer" checked> Browser is Answerer</label>
</section>

<section id="sec-offerer" style="display:none">
  <h2>2. Create Offer (browser &rarr; daemon)</h2>
  <button id="btn-create-offer">Create Offer</button>
  <textarea id="offer-out" readonly placeholder="Offer JSON will appear here..."></textarea>
  <p>Copy the above JSON into <code>/tmp/bolt-spike/offer.json</code>, then run the daemon as answerer.</p>
  <h2>3. Paste Answer (daemon &rarr; browser)</h2>
  <textarea id="answer-in" placeholder="Paste daemon answer JSON here..."></textarea>
  <button id="btn-apply-answer">Apply Answer</button>
</section>

<section id="sec-answerer">
  <h2>2. Paste Offer (daemon &rarr; browser)</h2>
  <textarea id="offer-in" placeholder="Paste daemon offer JSON here (from /tmp/bolt-spike/offer.json)..."></textarea>
  <button id="btn-apply-offer">Apply Offer &amp; Create Answer</button>
  <h2>3. Answer (browser &rarr; daemon)</h2>
  <textarea id="answer-out" readonly placeholder="Answer JSON will appear here..."></textarea>
  <p>Copy the above JSON into <code>/tmp/bolt-spike/answer.json</code>.</p>
</section>

<section>
  <h2>4. DataChannel</h2>
  <p>Status: <span id="dc-status" class="status">not connected</span></p>
  <textarea id="dc-send" placeholder="Type a message to send..."></textarea>
  <button id="btn-dc-send">Send</button>
</section>

<section>
  <h2>Log</h2>
  <div id="log" class="log"></div>
</section>

<script>
"use strict";
const logEl = document.getElementById("log");
function log(msg) {
  const ts = new Date().toISOString().slice(11, 23);
  logEl.textContent += `[${ts}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

// ── State ──────────────────────────────────────────────────
let pc = null;
let dc = null;

function setStatus(text, ok) {
  const el = document.getElementById("dc-status");
  el.textContent = text;
  el.className = "status " + (ok ? "ok" : "err");
}

// ── Mode switching ─────────────────────────────────────────
document.querySelectorAll('input[name="mode"]').forEach(r => {
  r.addEventListener("change", () => {
    document.getElementById("sec-offerer").style.display =
      r.value === "offerer" && r.checked ? "" : "none";
    document.getElementById("sec-answerer").style.display =
      r.value === "answerer" && r.checked ? "" : "none";
  });
});

// ── Helpers ────────────────────────────────────────────────
function createPC() {
  // LAN-only: no ICE servers
  pc = new RTCPeerConnection({ iceServers: [] });
  pc.oniceconnectionstatechange = () => log("ICE: " + pc.iceConnectionState);
  pc.onconnectionstatechange = () => {
    log("conn: " + pc.connectionState);
    if (pc.connectionState === "connected") setStatus("connected", true);
    if (pc.connectionState === "failed") setStatus("failed", false);
  };
  return pc;
}

async function collectBundle(pc, type) {
  return new Promise((resolve, reject) => {
    const candidates = [];
    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        candidates.push({ candidate: ev.candidate.candidate, mid: ev.candidate.sdpMid || "0" });
      } else {
        // Gathering complete
        resolve({
          description: { sdp_type: type, sdp: pc.localDescription.sdp },
          candidates: candidates
        });
      }
    };
    setTimeout(() => reject(new Error("ICE gathering timeout")), 15000);
  });
}

function applyBundle(pc, bundle) {
  const type = bundle.description.sdp_type === "offer" ? "offer" : "answer";
  pc.setRemoteDescription({ type: type, sdp: bundle.description.sdp });
  for (const c of bundle.candidates) {
    pc.addIceCandidate({ candidate: c.candidate, sdpMid: c.mid });
  }
  log("applied remote " + type + " + " + bundle.candidates.length + " candidates");
}

function setupDC(channel) {
  dc = channel;
  dc.onopen = () => {
    log("DataChannel open: " + dc.label);
    setStatus("open (" + dc.label + ")", true);
  };
  dc.onclose = () => {
    log("DataChannel closed");
    setStatus("closed", false);
  };
  dc.onmessage = (ev) => {
    const data = typeof ev.data === "string" ? ev.data : new TextDecoder().decode(ev.data);
    log("RECV: " + data);
    // Auto-echo bolt-hello-v1 for interop test
    if (data === "bolt-hello-v1") {
      dc.send("bolt-hello-v1");
      log("SENT (auto-echo): bolt-hello-v1");
    }
  };
}

// ── Browser as Offerer ─────────────────────────────────────
document.getElementById("btn-create-offer").addEventListener("click", async () => {
  try {
    createPC();
    const ch = pc.createDataChannel("bolt", { ordered: true });
    setupDC(ch);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log("created offer, gathering ICE...");
    const bundle = await collectBundle(pc, "offer");
    document.getElementById("offer-out").value = JSON.stringify(bundle, null, 2);
    log("offer ready (" + bundle.candidates.length + " candidates)");
  } catch (e) {
    log("ERROR: " + e.message);
  }
});

document.getElementById("btn-apply-answer").addEventListener("click", async () => {
  try {
    const bundle = JSON.parse(document.getElementById("answer-in").value);
    applyBundle(pc, bundle);
    log("answer applied, waiting for connection...");
  } catch (e) {
    log("ERROR: " + e.message);
  }
});

// ── Browser as Answerer ────────────────────────────────────
document.getElementById("btn-apply-offer").addEventListener("click", async () => {
  try {
    const bundle = JSON.parse(document.getElementById("offer-in").value);
    createPC();
    pc.ondatachannel = (ev) => {
      log("incoming DataChannel: " + ev.channel.label);
      setupDC(ev.channel);
    };
    applyBundle(pc, bundle);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    log("created answer, gathering ICE...");
    const answerBundle = await collectBundle(pc, "answer");
    document.getElementById("answer-out").value = JSON.stringify(answerBundle, null, 2);
    log("answer ready (" + answerBundle.candidates.length + " candidates)");
  } catch (e) {
    log("ERROR: " + e.message);
  }
});

// ── Manual send ────────────────────────────────────────────
document.getElementById("btn-dc-send").addEventListener("click", () => {
  const msg = document.getElementById("dc-send").value;
  if (!dc || dc.readyState !== "open") {
    log("ERROR: DataChannel not open");
    return;
  }
  dc.send(msg);
  log("SENT: " + msg);
});

log("ready");
</script>
</body>
</html>
